Œ¥bonds€¬cell_results…Ù$db092860-fb82-44f9-9543-7fcd08b3d39cˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ<script>const getParentCell = el => el.closest("pluto-cell")

const getHeaders = () => {
	const depth = Math.max(1, Math.min(6, 3)) // should be in range 1:6
	const range = Array.from({length: depth}, (x, i) => i+1) // [1, ..., depth]
	
	const selector = range.map(i => `pluto-notebook pluto-cell h${i}`).join(",")
	return Array.from(document.querySelectorAll(selector))
}

const indent = true
const aside = true

const render = (el) => html`${el.map(h => {
	const parent_cell = getParentCell(h)

	const a = html`<a 
		class="${h.nodeName}" 
		href="#${parent_cell.id}"
	>${h.innerText}</a>`
	/* a.onmouseover=()=>{
		parent_cell.firstElementChild.classList.add(
			'highlight-pluto-cell-shoulder'
		)
	}
	a.onmouseout=() => {
		parent_cell.firstElementChild.classList.remove(
			'highlight-pluto-cell-shoulder'
		)
	} */
	a.onclick=(e) => {
		e.preventDefault();
		h.scrollIntoView({
			behavior: 'smooth', 
			block: 'center'
		})
	}

	return html`<div class="toc-row">${a}</div>`
})}`

const tocNode = html`<nav class="plutoui-toc">
	<header>Table of Contents</header>
	<section></section>
</nav>`
tocNode.classList.toggle("aside", aside)
tocNode.classList.toggle("indent", aside)

const updateCallback = () => {
	tocNode.querySelector("section").replaceWith(
		html`<section>${render(getHeaders())}</section>`
	)
}
updateCallback()


const notebook = document.querySelector("pluto-notebook")


// We have a mutationobserver for each cell:
const observers = {
	current: [],
}

const createCellObservers = () => {
	observers.current.forEach((o) => o.disconnect())
	observers.current = Array.from(notebook.querySelectorAll("pluto-cell")).map(el => {
		const o = new MutationObserver(updateCallback)
		o.observe(el, {attributeFilter: ["class"]})
		return o
	})
}
createCellObservers()

// And one for the notebook's child list, which updates our cell observers:
const notebookObserver = new MutationObserver(() => {
	updateCallback()
	createCellObservers()
})
notebookObserver.observe(notebook, {childList: true})

// And finally, an observer for the document.body classList, to make sure that the toc also works when if is loaded during notebook initialization
const bodyClassObserver = new MutationObserver(updateCallback)
bodyClassObserver.observe(document.body, {attributeFilter: ["class"]})

invalidation.then(() => {
	notebookObserver.disconnect()
	bodyClassObserver.disconnect()
	observers.current.forEach((o) => o.disconnect())
})

return tocNode
</script><style>@media screen and (min-width: 1081px) {
	.plutoui-toc.aside {
		position:fixed; 
		right: 1rem;
		top: 5rem; 
		width:25%; 
		padding: 10px;
		border: 3px solid rgba(0, 0, 0, 0.15);
		border-radius: 10px;
		box-shadow: 0 0 11px 0px #00000010;
		/* That is, viewport minus top minus Live Docs */
		max-height: calc(100vh - 5rem - 56px);
		overflow: auto;
		z-index: 50;
		background: white;
	}
}

.plutoui-toc header {
	display: block;
	font-size: 1.5em;
	margin-top: 0.67em;
	margin-bottom: 0.67em;
	margin-left: 0;
	margin-right: 0;
	font-weight: bold;
	border-bottom: 2px solid rgba(0, 0, 0, 0.15);
}

.plutoui-toc section .toc-row {
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding-bottom: 2px;
}

.highlight-pluto-cell-shoulder {
	background: rgba(0, 0, 0, 0.05);
	background-clip: padding-box;
}

.plutoui-toc section a {
	text-decoration: none;
	font-weight: normal;
	color: gray;
}
.plutoui-toc section a:hover {
	color: black;
}

.plutoui-toc.indent section a.H1 {
	font-weight: 700;
	line-height: 1em;
}

.plutoui-toc.indent section a.H1 {
	padding-left: 0px;
}
.plutoui-toc.indent section a.H2 {
	padding-left: 10px;
}
.plutoui-toc.indent section a.H3 {
	padding-left: 20px;
}
.plutoui-toc.indent section a.H4 {
	padding-left: 30px;
}
.plutoui-toc.indent section a.H5 {
	padding-left: 40px;
}
.plutoui-toc.indent section a.H6 {
	padding-left: 50px;
}
</style>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØCð}ì[¬rootassigneeÀ§cell_idÙ$db092860-fb82-44f9-9543-7fcd08b3d39c¹depends_on_disabled_cellsÂ§runtimeÎ–ÛK§erroredÂÙ$a4327b5f-399b-4e81-bc22-72038757c275ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ]<div class="markdown"><h2>Power Iteration Method</h2>
<ul>
<li><p>This is the simplest method used for numerical solution of the eigenvalue problem.</p>
</li>
<li><p>Given a matrix <span class="tex">$A\in\mathbb&#123;C&#125;^&#123;N\times N&#125;$</span>, subject to some constraints:</p>
<ol>
<li><p>A is diagonalizable. For example, a Hermitian matrix.</p>
</li>
<li><p>The eigenvalues can be ordered as <span class="tex">$|\lambda_1| &gt; |\lambda_2| \ge \dots \ge |\lambda_N|$</span>. Here, <span class="tex">$\lambda_1$</span> is called <em>the dominent eigenvalue</em> and the corresponding eigenvector is called the <em>dominent eigenvector</em>.</p>
</li>
</ol>
</li>
<li><p>This method can only be used to calculate the dominent eigenvalue and eigenvector.</p>
</li>
</ul>
<div class="admonition tip"><p class="admonition-title">Power Iteration Method</p><p>As the matrix <span class="tex">$A$</span> is diagonalizable, the eigenvectors <span class="tex">$\mathbf&#123;v&#125;_1, \dots, \mathbf&#123;v&#125;_N$</span> are linearly independent and span <span class="tex">$\mathbb&#123;R&#125;^N$</span>. So, for some <span class="tex">$\mathbf&#123;x&#125;_0 \in \mathbb&#123;R&#125;^N$</span> we have:</p>
<p class="tex">$$\mathbf&#123;x&#125;_0 &#61; \sum_&#123;i&#61;1&#125;^&#123;N&#125; c_i \mathbf&#123;v&#125;_i$$</p>
<p class="tex">$$\implies \mathbf&#123;x&#125;_n &#61; A^n\mathbf&#123;x&#125;_0 &#61; \sum_&#123;i&#61;1&#125;^&#123;N&#125; c_i A^n \mathbf&#123;v&#125;_i &#61; \sum_&#123;i&#61;1&#125;^&#123;N&#125; c_i \lambda_i^n \mathbf&#123;v&#125;_i$$</p>
<p class="tex">$$\implies \mathbf&#123;x&#125;_n &#61; c_1 \lambda_1^n \mathbf&#123;v&#125;_1 &#43; \lambda_1^n\sum_&#123;i&#61;2&#125;^&#123;N&#125; c_i \frac&#123;\lambda_i^n&#125;&#123;\lambda_1^n&#125; \mathbf&#123;v&#125;_i$$</p>
<p>Now, as <span class="tex">$n \rightarrow \infty$</span>, we get that <span class="tex">$\mathbf&#123;x&#125;_n \rightarrow c_1 \lambda_1^n \mathbf&#123;v&#125;_1$</span> as the dominent eigenvalue is strictly greater than all other eigenvalues. Thus we can get the dominent eigenvector by repetative multiplication of a vector <span class="tex">$\mathbf&#123;x&#125;_0$</span> by matrix <span class="tex">$A$</span> and then normalizing the result.</p>
<p>We can also find the dominent eigenvalue by using the <a href="https://en.wikipedia.org/wiki/Rayleigh_quotient">Rayleigh quotient</a> as:</p>
<p class="tex">$$\lim_&#123;n\to\infty&#125; \frac&#123;\mathbf&#123;x&#125;_n^â€  A \mathbf&#123;x&#125;_n&#125;&#123;\mathbf&#123;x&#125;_n^*\cdot\mathbf&#123;x&#125;_n&#125; &#61; \lambda_1$$</p>
</div>
<ul>
<li><p>We can&#39;t use this method if <span class="tex">$c_1&#61;0$</span> i.e. <span class="tex">$\mathbf&#123;x&#125;_0$</span> and <span class="tex">$\mathbf&#123;v&#125;_1$</span> are ortogonal. But as we can&#39;t know the dominent eigenvector beforehand we can make a guess and hope for the best.</p>
</li>
<li><p>Also, if <span class="tex">$|\lambda_1| &gt; 1$</span> then with each iteration the components of the iterated vector will grow and may reach out of bounds of the precision of floating point numbers for large <span class="tex">$n$</span>. To prevent this we can normalize the vector again at each iteration resulting in the <em>normalized power iteration method</em>.</p>
</li>
<li><p>This algorithm has <strong>linear convergence</strong> for any general matrix, whereas <strong>quadratic convergence</strong> for Hermitian or real-symmetric matrices. The closer <span class="tex">$\mathbf&#123;x&#125;_0$</span> is to <span class="tex">$\mathbf&#123;v&#125;_1$</span>, the better the convergence will be.</p>
</li>
</ul>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØCðuOƒo¬rootassigneeÀ§cell_idÙ$a4327b5f-399b-4e81-bc22-72038757c275¹depends_on_disabled_cellsÂ§runtimeÎ _9a§erroredÂÙ$766e180a-004b-4fa4-a55e-a2ca892645f8ˆ¦queuedÂ±published_objects€§runningÂ¦output…¤body¨<br><br>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØCðuUÐÿ¬rootassigneeÀ§cell_idÙ$766e180a-004b-4fa4-a55e-a2ca892645f8¹depends_on_disabled_cellsÂ§runtimeÎ &Ãt§erroredÂÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9cˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÙK<div class="markdown"><h1>Preliminaries: The Eigenvalue Problem</h1>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØCðu@ºI¬rootassigneeÀ§cell_idÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9c¹depends_on_disabled_cellsÂ§runtimeÍ,§erroredÂÙ$2e38803f-a24b-4b73-b947-1a4dbe11a60cˆ¦queuedÂ±published_objects€§runningÂ¦output…¤bodyÚ…<div class="markdown"><div class="admonition info"><p class="admonition-title">Code</p><p>To check the convergence we check for the difference between consecutive rayleigh coefficients to be small within some limit. If we only need the to calculate the eigenvector then we can save time by not using rayleigh coefficients and only checking for the norm of difference between the vectors in two consecutive iterations to be within some small limit.</p>
<pre><code class="language-julia">using LinearAlgebra

rayleigh_quotient&#40;A::Matrix, x::Vector&#41; &#61; dot&#40;x, A, x&#41; / dot&#40;x, x&#41;

#&#61; 
Example Matrix
Dominent Eigenvalue: 8.45188
Dominent Eigenvector: &#91;0.3398 âˆ’ 0.2345i, 0.4913 &#43; 0.5107i, 0.5011 âˆ’ 0.2762i&#93;
&#61;#
A &#61; &#91; 4&#43;0im  0-1im  2&#43;0im;
	  0&#43;1im  2&#43;0im  2&#43;7im;
	  2&#43;0im  2-7im -2&#43;0im&#93;

# Starting Vector
x &#61; normalize&#40;&#91;1&#43;0im;
			   1&#43;0im; 
			   1&#43;0im&#93;&#41;

RQold &#61; 0
RQnew &#61; rayleigh_quotient&#40;A, x&#41;

# Power Iteration
while &#40;abs&#40;RQnew - RQold&#41; &gt; 1e-6&#41;
	RQold &#61; RQnew
	x &#61; normalize&#40;A * x&#41;
	RQnew &#61; rayleigh_quotient&#40;A, x&#41;
end

println&#40;&quot;The dominent eigenvalue is: &#36;&#40;RQnew&#41;&quot;&#41;
println&#40;&quot;The dominent eigenvector is: &#36;&#40;x&#41;&quot;&#41;</code></pre>
<p class="tex">$$\quad$$</p>
</div>
</div>°persist_js_stateÂ¤mime©text/html²last_run_timestampËAØCðuRn¬rootassigneeÀ§cell_idÙ$2e38803f-a24b-4b73-b947-1a4dbe11a60c¹depends_on_disabled_cellsÂ§runtimeÍp§erroredÂ±cell_dependencies…Ù$db092860-fb82-44f9-9543-7fcd08b3d39c„´precedence_heuristic§cell_idÙ$db092860-fb82-44f9-9543-7fcd08b3d39c´downstream_cells_map§PlutoUI‘Ù$db092860-fb82-44f9-9543-7fcd08b3d39c²upstream_cells_map‚§PlutoUI‘Ù$db092860-fb82-44f9-9543-7fcd08b3d39c·PlutoUI.TableOfContentsÙ$a4327b5f-399b-4e81-bc22-72038757c275„´precedence_heuristic§cell_idÙ$a4327b5f-399b-4e81-bc22-72038757c275´downstream_cells_map€²upstream_cells_map‚§@md_str¨getindexÙ$766e180a-004b-4fa4-a55e-a2ca892645f8„´precedence_heuristic§cell_idÙ$766e180a-004b-4fa4-a55e-a2ca892645f8´downstream_cells_map€²upstream_cells_map©@html_strÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9c„´precedence_heuristic§cell_idÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9c´downstream_cells_map€²upstream_cells_map‚§@md_str¨getindexÙ$2e38803f-a24b-4b73-b947-1a4dbe11a60c„´precedence_heuristic§cell_idÙ$2e38803f-a24b-4b73-b947-1a4dbe11a60c´downstream_cells_map€²upstream_cells_map‚§@md_str¨getindex´cell_execution_order•Ù$db092860-fb82-44f9-9543-7fcd08b3d39cÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9cÙ$a4327b5f-399b-4e81-bc22-72038757c275Ù$2e38803f-a24b-4b73-b947-1a4dbe11a60cÙ$766e180a-004b-4fa4-a55e-a2ca892645f8©shortpathµeigenvalue-problem.jl®process_status¥ready¤pathÙm/home/runner/work/computational-physics-notes/computational-physics-notes/preliminaries/eigenvalue-problem.jlªcell_order•Ù$60dfd5d2-f809-11eb-3e94-af4a3099da9cÙ$db092860-fb82-44f9-9543-7fcd08b3d39cÙ$a4327b5f-399b-4e81-bc22-72038757c275Ù$2e38803f-a24b-4b73-b947-1a4dbe11a60cÙ$766e180a-004b-4fa4-a55e-a2ca892645f8¥nbpkg‡²installed_versions§PlutoUI¥0.7.9°terminal_outputs§PlutoUIÚ	[32m[1m   Installed[22m[39m Reexport â”€â”€â”€ v1.1.0
[32m[1m   Installed[22m[39m Suppressor â”€ v0.2.0
[32m[1m   Installed[22m[39m PlutoUI â”€â”€â”€â”€ v0.7.9
[32m[1m  No Changes[22m[39m to `/tmp/jl_m1SUat/Project.toml`
[32m[1m  No Changes[22m[39m to `/tmp/jl_m1SUat/Manifest.toml`
[32m[1mPrecompiling[22m[39m project...
[32m  âœ“ [39m[90mReexport[39m
[32m  âœ“ [39m[90mSuppressor[39m
[32m  âœ“ [39mPlutoUI
  3 dependencies successfully precompiled in 4 seconds (2 already precompiled)
§enabledÃ·restart_recommended_msgÀ´restart_required_msgÀ­busy_packages¬instantiatedÃ«cell_inputs…Ù$db092860-fb82-44f9-9543-7fcd08b3d39c„§cell_idÙ$db092860-fb82-44f9-9543-7fcd08b3d39c°running_disabledÂ¤codeÙ3begin
	using PlutoUI
	PlutoUI.TableOfContents()
end«code_foldedÃÙ$a4327b5f-399b-4e81-bc22-72038757c275„§cell_idÙ$a4327b5f-399b-4e81-bc22-72038757c275°running_disabledÂ¤codeÚ	Ymd"""
## Power Iteration Method

- This is the simplest method used for numerical solution of the eigenvalue problem.

- Given a matrix $A\in\mathbb{C}^{N\times N}$, subject to some constraints:
  1. A is diagonalizable. For example, a Hermitian matrix.
  2. The eigenvalues can be ordered as $|\lambda_1| > |\lambda_2| \ge \dots \ge |\lambda_N|$. Here, $\lambda_1$ is called _the dominent eigenvalue_ and the corresponding eigenvector is called the _dominent eigenvector_.

- This method can only be used to calculate the dominent eigenvalue and eigenvector.

!!! tip "Power Iteration Method"
	As the matrix $A$ is diagonalizable, the eigenvectors $\mathbf{v}_1, \dots, \mathbf{v}_N$ are linearly independent and span $\mathbb{R}^N$. So, for some $\mathbf{x}_0 \in \mathbb{R}^N$ we have:

	$\mathbf{x}_0 = \sum_{i=1}^{N} c_i \mathbf{v}_i$
	$\implies \mathbf{x}_n = A^n\mathbf{x}_0 = \sum_{i=1}^{N} c_i A^n \mathbf{v}_i = \sum_{i=1}^{N} c_i \lambda_i^n \mathbf{v}_i$
	$\implies \mathbf{x}_n = c_1 \lambda_1^n \mathbf{v}_1 + \lambda_1^n\sum_{i=2}^{N} c_i \frac{\lambda_i^n}{\lambda_1^n} \mathbf{v}_i$
	Now, as $n \rightarrow \infty$, we get that $\mathbf{x}_n \rightarrow c_1 \lambda_1^n \mathbf{v}_1$ as the dominent eigenvalue is strictly greater than all other eigenvalues. Thus we can get the dominent eigenvector by repetative multiplication of a vector $\mathbf{x}_0$ by matrix $A$ and then normalizing the result.

	We can also find the dominent eigenvalue by using the [Rayleigh quotient](https://en.wikipedia.org/wiki/Rayleigh_quotient) as:
	
	$\lim_{n\to\infty} \frac{\mathbf{x}_n^â€  A \mathbf{x}_n}{\mathbf{x}_n^*\cdot\mathbf{x}_n} = \lambda_1$

- We can't use this method if $c_1=0$ i.e. $\mathbf{x}_0$ and $\mathbf{v}_1$ are ortogonal. But as we can't know the dominent eigenvector beforehand we can make a guess and hope for the best.

- Also, if $|\lambda_1| > 1$ then with each iteration the components of the iterated vector will grow and may reach out of bounds of the precision of floating point numbers for large $n$. To prevent this we can normalize the vector again at each iteration resulting in the _normalized power iteration method_.

- This algorithm has **linear convergence** for any general matrix, whereas **quadratic convergence** for Hermitian or real-symmetric matrices. The closer $\mathbf{x}_0$ is to $\mathbf{v}_1$, the better the convergence will be.

"""«code_foldedÃÙ$766e180a-004b-4fa4-a55e-a2ca892645f8„§cell_idÙ$766e180a-004b-4fa4-a55e-a2ca892645f8°running_disabledÂ¤code®html"<br><br>"«code_foldedÃÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9c„§cell_idÙ$60dfd5d2-f809-11eb-3e94-af4a3099da9c°running_disabledÂ¤codeÙ+md"# Preliminaries: The Eigenvalue Problem"«code_foldedÃÙ$2e38803f-a24b-4b73-b947-1a4dbe11a60c„§cell_idÙ$2e38803f-a24b-4b73-b947-1a4dbe11a60c°running_disabledÂ¤codeÚ(md"""
!!! info "Code"
	
	To check the convergence we check for the difference between consecutive rayleigh coefficients to be small within some limit. If we only need the to calculate the eigenvector then we can save time by not using rayleigh coefficients and only checking for the norm of difference between the vectors in two consecutive iterations to be within some small limit.

	```julia
	using LinearAlgebra

	rayleigh_quotient(A::Matrix, x::Vector) = dot(x, A, x) / dot(x, x)

	#= 
	Example Matrix
	Dominent Eigenvalue: 8.45188
	Dominent Eigenvector: [0.3398 âˆ’ 0.2345i, 0.4913 + 0.5107i, 0.5011 âˆ’ 0.2762i]
	=#
	A = [ 4+0im  0-1im  2+0im;
		  0+1im  2+0im  2+7im;
		  2+0im  2-7im -2+0im]

	# Starting Vector
	x = normalize([1+0im;
				   1+0im; 
				   1+0im])

	RQold = 0
	RQnew = rayleigh_quotient(A, x)

	# Power Iteration
	while (abs(RQnew - RQold) > 1e-6)
		RQold = RQnew
		x = normalize(A * x)
		RQnew = rayleigh_quotient(A, x)
	end

	println("The dominent eigenvalue is: $(RQnew)")
	println("The dominent eigenvector is: $(x)")
	```
	$\quad$
"""«code_foldedÃ«notebook_idÙ$e9b83984-f83c-11eb-2ff3-d50a42fa7244«in_temp_dirÂ